# -*- coding: utf-8 -*-
"""
Created on Wed Apr  2 16:27:10 2014

This is a helper module with some functions to fastly use the data generated
by PAM in Nest

@author: martin
"""

import csv
import io
import logging
import os
import zipfile
import nest
import copy
import numpy as np

logger = logging.getLogger(__package__)

def Connect(g1, g2, connections, delays, w_mean, w_sd, d_mean, d_sd):
    """ Connects group g1 of neurons with group g2 of neurons using the
    connection- and delay-matrix generated by PAM
    
    g1,
    g2              : Groups of neurons
    
    connnections    : Connection matrix generated in PAM, which is a 
                      n * s matrix (n pre-synaptic neurons times s synapses)
    
    delays          : Delay matrix generated in PAM
    
    w_mean          : The mean weight
    w_sd            : The standard deviation for the weight
    
    delay_factor    : A factor for the delay
    
    
    Example:
        
        Connect(g1, g2, m['c'][0], m['d'][0], 2.0, DELAY_FACTOR)
    """
    for i in range(0, len(connections)):
        for j in range(0, len(connections[i])):
            # if a synapse has really been created
            if connections[i][j] > 0:
                weight = np.random.randn(1)[0] * w_sd + w_mean
                if w_mean > 0:
                    weight = max(weight, 0)
                if w_mean < 0:
                    weight = min(weight, 0)
                    
                delay = np.random.randn(1)[0] * d_sd + d_mean
                nest.Connect([g1[i]], [g2[connections[i][j]]], 
                             params={'weight': np.random.randn(1)[0] * w_sd + w_mean, 
                                     'delay': max(delays[i][j] * delay, 0.1)})


def CreateNetwork(data, neuron_type, w_mean=[1.], w_sd=[1.], d_mean=[1.], d_sd=[1.]):
    """ Creates the NEST-network for the dataset generated by PAM
    data         : the network model obtained from PAM
    w_mean, w_sd : mean weights and standard deviation for each mapping or
                   one value for all mappings
    d_mean, d_sd : mean dealy and standard deviation for each mapping or
                   one value for all mappings
    """
    
    if (len(w_mean) > 1) & (len(w_mean) < len(data['connections'][0])):
        raise Exception("length of weight-vector does not match length of " +
            "connection list")
            
    if len(w_mean) != len(w_sd):
        raise Exception("length of weights-mean and weights-sd-vector do not " +
                        "match")
        
    if (len(d_mean) > 1) & (len(d_mean) < len(data['connections'][0])):
        raise Exception("length of delay-vector does not match length of " +
            "connection list")
            
    if len(d_mean) != len(d_sd):
        raise Exception("length of delay-mean and delay-sd-vector do not " +
                        "match")        
            
    neurongroups = []
    # first, create the neurongroups
    for ng in data['neurongroups'][0]:
        neurongroups.append(nest.Create(neuron_type, ng[-1]))
        
    # create connections between neuron groups
    for i, conn in enumerate(data['connections'][0]):
        if (len(w_mean) == 1):
            weight = w_mean[0]
            sd = w_sd[0]
        else:
            weight = w_mean[i]
            sd = w_sd[i]
        
        if (len(d_mean) == 1):
            delay = d_mean[0]
            delay_sd = d_sd[0]
        else:
            delay = d_mean[i]
            delay_sd = d_sd[i] 
            
        Connect(neurongroups[conn[1]], neurongroups[conn[2]], 
                data['c'][conn[0]], data['d'][conn[0]], 
                weight, sd, delay, delay_sd)
        
    return neurongroups        
        
#def convertToDict(data):
#    """ converts a given list of neuron groups to a dictionary """


def import_connections(filepath):
    matrices = copy.deepcopy(SUPPORTED_SUFFIXES)

    with zipfile.ZipFile(filepath, "r", zipfile.ZIP_DEFLATED) as file:
        for filename in file.namelist():
            filename_split = os.path.splitext(filename)
            filename_suffix = ''.join(filename_split[:-1]).rsplit("_", 1)[-1]
            filename_extension = filename_split[-1]

            if filename_extension not in SUPPORTED_FILETYPES.keys():
                logger.error("filetype not supported")
                raise Exception("filetype not supported")

            if filename_suffix not in SUPPORTED_SUFFIXES.keys():
                logger.error("unknown suffix")
                raise Exception("unknown suffix")

            data = io.StringIO(unicode(file.read(filename)))
            func = SUPPORTED_FILETYPES[filename_extension]

            matrix = func(data)
            
            if filename_suffix in FULL_INTS.keys():
                matrix = convertToIntFull(matrix)
                
            if filename_suffix in PARTLY_INTS.keys():
                matrix = convertToIntPartly(matrix)                

            matrices[filename_suffix].append(matrix)

    return matrices


def import_UVfactors(filepath):
    result = []
    names = []
    with zipfile.ZipFile(filepath, "r", zipfile.ZIP_DEFLATED) as file:
        for filename in file.namelist():
            filename_split = os.path.splitext(filename)  
            filename_extension = filename_split[-1]
            data = io.StringIO(unicode(file.read(filename)))
            func = SUPPORTED_FILETYPES[filename_extension]
            matrix = func(data)
            result.append(matrix)
            names.append(filename_split[0])
    return result, names
            

def convertToIntFull(matrix):
    return [[int(i) for i in row] for row in matrix]
    
def convertToIntPartly(matrix):
    return [[row[0], row[1], int(row[2])] for row in matrix]    

def csv_read(data):
    reader = csv.reader(
        data,
        delimiter=";",
        quoting=csv.QUOTE_NONNUMERIC
    )
    return [row for row in reader]


SUPPORTED_FILETYPES = {
    ".csv": csv_read
}

FULL_INTS = {
    "c": [],
    "connections": []
}

PARTLY_INTS = {
    "neurongroups": []
}

SUPPORTED_SUFFIXES = {
    "d": [],
    "c": [],
    "connections": [],
    "neurongroups": []
}



